# Chromium GN 스코핑 및 실행 흐름 (Scoping & Execution) 가이드

GN(Generate Ninja)의 빌드 파일 처리 방식과 변수의 유효 범위(Scope)에 대한 이해는 복잡한 빌드 로직을 작성할 때 필수적입니다.

## 1. 실행 모델 (Execution Model)

GN은 빌드 그래프를 생성하기 위해 다음과 같은 순서로 파일을 처리합니다.

### 1단계: `.gn` 파일 로드
소스 트리의 루트(Source Root)에 있는 `.gn` 설정 파일을 가장 먼저 읽습니다. 이 파일은 주로 빌드 설정 파일의 위치(`buildconfig`)를 지정하는 역할을 합니다.

### 2단계: `BUILDCONFIG.gn` 실행
`.gn` 파일에서 지정된 설정 파일(보통 `//build/config/BUILDCONFIG.gn`)을 실행합니다.
*   이 파일은 **전역 스코프**로 동작합니다.
*   여기서 설정된 변수(`is_linux`, `target_cpu` 등)와 `set_defaults` 설정은 이후 로드되는 모든 `BUILD.gn` 파일에서 사용할 수 있습니다.

### 3단계: 타겟 파일 로드
GN은 빌드 대상 타겟(Target)을 찾기 위해 `BUILD.gn` 파일들을 로드합니다.
*   `gn gen` 명령 시점에는 모든 파일을 다 읽는 것이 아니라, 루트 타겟에서 시작하여 `deps`, `public_deps`, `data_deps` 등을 통해 연결된 파일들만 재귀적으로 로드합니다.
*   각 `BUILD.gn` 파일은 격리된 환경에서 실행됩니다.

## 2. 스코프 규칙 (Scoping Rules)

GN은 렉시컬 스코프(Lexical Scoping)를 따르지만, 블록(Block)의 종류에 따라 스코프 생성 여부가 다릅니다.

### 파일 스코프 (File Scope)
각 파일(`BUILD.gn`, `.gni`)은 자신만의 스코프를 가집니다.
*   `BUILDCONFIG.gn`에서 정의한 전역 변수를 제외하고, 다른 파일의 변수는 보이지 않습니다.
*   `import`를 사용하면 `.gni` 파일의 변수들이 현재 파일 스코프로 복사됩니다.

### 제어문 스코프 (Control Flow)

1.  **`if` / `else`**: 새로운 스코프를 **생성하지 않습니다**.
    *   블록 내부에서 변수를 정의하거나 수정하면, 블록이 끝난 후에도 변경 사항이 유지됩니다.
    ```gn
    if (is_win) {
      suffix = ".exe"
    } else {
      suffix = ""
    }
    # 여기서 suffix 접근 가능
    executable("app$suffix") { ... }
    ```

2.  **`foreach`**: 새로운 스코프를 **생성합니다**.
    *   반복문 내부에서 만든 변수는 외부에서 접근할 수 없습니다.
    ```gn
    foreach(src, sources) {
      temp_name = "foo"  # 외부로 유출되지 않음
    }
    # print(temp_name)  # Error: Undefined variable
    ```

### 타겟 및 템플릿 스코프
`executable`, `source_set` 등의 타겟 정의나 `template` 호출은 새로운 스코프를 생성합니다.
*   외부 스코프의 변수를 읽을 수는 있습니다.
*   내부에서 변수에 값을 할당하면, 외부 변수를 덮어쓰지 않고 새로운 로컬 변수를 생성합니다 (Shadowing).

```gn
my_var = "global"

executable("my_app") {
  my_var = "local"  # 로컬 변수 생성, 외부 my_var는 영향 없음
  print(my_var)     # "local"
}

print(my_var)       # "global"
```

## 3. Import와 Private 변수

`.gni` 파일을 `import` 할 때, 해당 파일의 모든 변수가 현재 스코프로 들어오는 것은 아닙니다.

*   **Private 변수**: 이름이 밑줄(`_`)로 시작하는 변수는 해당 파일 내부에서만 사용되며, `import` 하는 쪽으로 전달되지 않습니다.

```gn
# my_utils.gni
_internal_helper = "secret"  # import 시 보이지 않음
public_var = "hello"         # import 시 보임
```

## 4. 템플릿 실행과 `invoker`

템플릿(Template)은 사용자 정의 함수처럼 동작하며, 호출 시 전달된 인자들은 `invoker`라는 특수 변수(Scope 타입)에 담깁니다.

```gn
template("my_rule") {
  # 호출한 스코프의 변수가 아니라, invoker 내부의 변수를 사용해야 함
  print(invoker.sources)
  
  # 템플릿 내부 변수는 외부에 영향을 주지 않음
  helper_var = 123
}

my_rule("target") {
  sources = [ "a.cc" ]
}
```
