# Chromium GN 패턴 (Patterns) 가이드

GN(Generate Ninja)을 효과적으로 사용하기 위해 Chromium 프로젝트 등에서 자주 사용되는 설계 패턴과 관례(Idioms)를 정리합니다.

## 1. Source Set vs Static Library

Chromium 프로젝트에서는 `static_library` 대신 `source_set`을 주로 사용합니다.

### 차이점
*   **`static_library`**: `.a` (또는 `.lib`) 아카이브 파일을 생성합니다. 링크 시 사용되지 않는 심볼이 제거될 수 있지만, 아카이빙 오버헤드가 있습니다.
*   **`source_set`**: 중간 파일 없이 객체 파일(`.o`)들의 목록으로 취급됩니다. 최종 실행 파일이나 공유 라이브러리에 링크될 때, 필요한 객체 파일만 직접 전달되므로 링킹 속도가 빠릅니다.

### 권장 패턴
대부분의 내부 모듈은 `source_set`으로 정의하고, 최종 산출물(`executable`, `shared_library`)에서 이를 링크하는 방식을 권장합니다.

```gn
# 권장
source_set("my_util") {
  sources = [ "util.cc", "util.h" ]
}

executable("app") {
  deps = [ ":my_util" ]
}
```

## 2. 컴포넌트 빌드 (Component Build)

개발 중에는 링크 속도를 높이기 위해 동적 라이브러리를 많이 사용하고, 배포 시에는 성능을 위해 단일 바이너리(또는 적은 수의 라이브러리)로 빌드하는 패턴입니다.

### `component` 템플릿
GN 내장 타겟은 아니지만, Chromium의 `//build/config/BUILDCONFIG.gn` 등에서 정의하여 사용하는 템플릿입니다.
*   `is_component_build = true` (주로 Debug): `shared_library`로 동작.
*   `is_component_build = false` (주로 Release): `static_library` 또는 `source_set`으로 동작.

```gn
component("base") {
  sources = [ ... ]
  defines = [ "BASE_IMPLEMENTATION" ] # DLL Export/Import 매크로 제어용
}
```

## 3. 설정 전파 (Config Propagation)

라이브러리를 작성할 때, 해당 라이브러리를 사용하는 쪽(Client)에서 필요한 설정(include 경로 등)을 자동으로 적용받게 하는 패턴입니다.

### `public_configs` 사용
자신의 헤더 파일을 include 하기 위해 필요한 경로를 `public_configs`에 담아 노출합니다.

```gn
config("my_lib_public") {
  include_dirs = [ "include" ]
}

source_set("my_lib") {
  sources = [ "src/lib.cc" ]
  # 내부 빌드용 (private)
  include_dirs = [ "src" ]
  # 외부 노출용 (public)
  public_configs = [ ":my_lib_public" ]
}
```

## 4. 액션 스크립트 경로 처리 (Action Script Paths)

`action` 타겟을 사용하여 Python 스크립트를 실행할 때, 파일 경로를 올바르게 전달하는 패턴입니다.

### `rebase_path` 활용
스크립트는 빌드 디렉토리(`root_build_dir`)를 기준으로 실행되므로, 소스 파일 경로는 `rebase_path`를 통해 변환해야 합니다.

```gn
action("generate_code") {
  script = "tools/gen.py"
  sources = [ "data.json" ]
  outputs = [ "$target_gen_dir/data.cc" ]

  args = [
    "--input", rebase_path(sources[0], root_build_dir),
    "--output", rebase_path(outputs[0], root_build_dir),
  ]
}
```

## 5. 템플릿 래퍼 (Template Wrappers)

반복되는 타겟 설정을 줄이기 위해 템플릿을 만들 때, 호출자의 변수를 내부 타겟으로 전달하는 패턴입니다.

### `forward_variables_from`
`invoker`의 변수를 내부 타겟으로 전달하되, 템플릿 내부에서만 사용하는 변수는 제외하거나 처리 후 전달합니다.

```gn
template("my_test_executable") {
  executable(target_name) {
    testonly = true
    forward_variables_from(invoker, "*", [ "extra_flags" ])
    
    if (defined(invoker.extra_flags)) {
      args = invoker.extra_flags
    }
    
    # 공통 의존성 추가
    if (!defined(deps)) { deps = [] }
    deps += [ "//testing:gtest_main" ]
  }
}
```

## 6. 의존성 가시성 제어 (Visibility Control)

모듈의 내부 구현 세부 사항을 숨기고, 공개 API만 노출하기 위해 `visibility`를 사용하는 패턴입니다.

```gn
# 내부 구현용 라이브러리
source_set("backend_impl") {
  visibility = [ ":backend" ] # :backend 타겟에서만 접근 가능
  sources = [ "internal.cc" ]
}

# 공개 라이브러리
component("backend") {
  public_deps = [ ":backend_impl" ]
}
```
